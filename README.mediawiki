==Description==

Proposer une approche Arduino avec eLua sur la carte STM32F4-DISCOVERY.

==Récupérer les sources==

Le code source du projet est disponible sur github.
 $ '''git clone git@github.com:SalemHarrache/ricm4-Easy-Elua.git'''

==Instalation==

Une fois télécharger, il faut lancer le script d’installation (debian/ubuntu) qui met en place l'environnement, à savoir Sourcery toolchain et l'utilitaire de flash de stlink:
 '''$ cd ricm4-Easy-Elua.git
 '''$ ./debian_install.sh
 '''   -------------------------------------------------------------------------------
 '''   Install prerequisites
 '''   -------------------------------------------------------------------------------
 '''         [OK] Install development tools
 '''   -------------------------------------------------------------------------------
 '''   Install Sourcery ARM toolchain version 2011.03-42
 '''   -------------------------------------------------------------------------------
 '''         [OK] Donwload Sourcery G++ Lite 2011.03-42 for ARM EABI
 '''         [OK] Unpack Sourcery G++ Lite 2011.03-42 for ARM EABI
 '''   -------------------------------------------------------------------------------
 '''   Install ST-FLASH from stlink
 '''   -------------------------------------------------------------------------------
 '''         [OK] Git clone stlink
 '''         [OK] Compiling st-flash
 '''   -------------------------------------------------------------------------------
 '''   Install elua
 '''   -------------------------------------------------------------------------------
 '''         [OK] Git clone elua
 '''         [OK] Compiling elua for STM32F4DSCY
 '''         [OK] Clean
 '''
 '''   Installation succeed !
 '''   -------------------------------------------------------------------------------
 '''   Sourcery toolchain folder:        /home/salem/project/projet-ricm4/env/CodeSourcery/arm-2011.03
 '''   stlink flash utils floder:        /home/salem/project/projet-ricm4/env/utils/
 '''   Elua floder:                      /home/salem/project/projet-ricm4/elua
 '''   Activate env:                     /home/salem/project/projet-ricm4/activate_env.sh
 '''   -------------------------------------------------------------------------------
 '''$

==Utilisation==

Le script activate_env.sh permet simplement d'activer à la demande l'environnement pour ne pas polluer le '''PATH''' de votre machine. Pour l'utiliser :
 $ '''source activate_env.sh
ou
 $ '''. activate_env.sh

Pour lancer des programmes sur la carte, il faut utiliser le script '''flash.sh''' suivi du nom de votre fichier. La carte doit etre branchée sur les deux ports usb (alimentation + com).

Vous devez importer le fichier '''arduino_wraper.lua''' en début du programme avec l'instruction '''require("arduino_wraper")'''

Exemple : blink.lua
'''<pre>
require("arduino_wraper")

function App:setup()
    self.ledpin = getPin("PD_13") -- Pin PD_13 has a LED connected
    pinMode(self.ledpin, OUTPUT) -- Initialize the digital pin as an output.
end

function App:loop()
    digitalWrite(self.ledpin, HIGH)    -- set the LED on
    delay(1000)                      -- wait for a second
    digitalWrite(self.ledpin, LOW)     -- set the LED off
    delay(1000)                      -- wait for a second
end

app = App:new("Blink led")
app:run()
</pre>

 $ ./flash.sh examples/blink.lua

Le script s'occupe d'ajoute le fichier arduino_wraper, de compiler elua, de flasher la carte avec l'image générée. Le programme (ici blink.lua) se lance automatiquement. (parfois il faut appuyer sur reset ou débrancher puis rebrancher l'alimentation)

==Suivi du projet==

Vous pouvez suivre ici l’avancement du projet semaine par semaine. L

===Semaine 0===
*Etudier Lua
*Comprendre l'approche de Arduino et se familiariser avec leurs outils
*Essayer l'environnement Elua
*Comprendre le sujet

===Semaine 1===
* Faire fonctionner la carte
* Installation du Sourcery G++ (finalement pas utilisé pour l'instant)
* Installer de la toolchain cortex m3
** https://github.com/esden/summon-arm-toolchain


===Semaine 2===
Lundi:
*Continuation de l'installation:
** Toolchain cortex m3
** StLink : https://github.com/texane/stlink
*Tests:
** "Building and running a program in SRAM"
** Debut du test: "Building and flashing a program"

Mardi:
*Suite des du test de Flash

===Semaine 3===

Simplification du programme blink_flask de stlink pour réussir le flash sur STM32F4 : Aucun résultat concluant.

'''TODO :'''
* Utiliser l’historique git pour voir les modifications qui ont été faites sur cette partie.
* Étudier le fork suivant sur github : https://github.com/bikeNomad/stlink

En attendant, test de libopencm3 (anciennement libopenstm32) :

 $ '''git clone git://libopencm3.git.sourceforge.net/gitroot/libopencm3/libopencm3'''
 $ cd libopencm3
 $ make
 $ cd examples/stm32/f4/stm32f4-discovery/miniblink
 $ make
 $ sudo \$STLINK_PATH/flash write ./miniblink.bin 0x8000000

'''Test OK'''. On garde sous le coude cette librairie, en attendant on attaque la mise en place de l'environnement eLua sur la carte.

Environnement eLua avec la plateforme pour la stm32f4-discovery:

 $ '''git://github.com/jsnyder/elua.git'''
 $ '''git checkout bikeNomad-master'''

Installer luarocks (permet l'installation des modules Lua):

 $ sudo apt-get install luarocks
 $ Voir: '''http://www.luarocks.org/'''
Exemples :
 $ luarocks install luafilesystem ou
 $ '''git://github.com/keplerproject/luafilesystem.git'''
 $ Voir: '''http://keplerproject.github.com/luafilesystem/'''
 $ luarocks install md5
 $ '''git://github.com/keplerproject/md5.git'''
 $ Voir: '''http://www.keplerproject.org/md5/'''

Installer scons
 $ sudo apt-get install scons

Lancer la compilation :
 $ cd elua
 $ scons board=STM32F4DSCY prog

Résultat attendu:

 Compiling eLua ...
 CPU:  STM32F407VG
 Board:  STM32F4DSCY
 Platform:  stm32f4
 Allocator:  newlib
 Boot Mode:  standard
 Target:  lua
 Toolchain:  codesourcery
 ROMFS mode:  verbatim

===Semaine 4===
Vacances

===Semaine 5===

Fork eLua : https://github.com/SalemHarrache/elua/tree/polytech-master

 $ git clone git@github.com:SalemHarrache/elua.git

Les deux branches à nous sont:

*'''polytech-master''' : Reprend les derniers commits de James Snyder

 $ git checkout polytech-master
 $ scons board=STM32F4DSCY prog

'''TODO''' : Pourquoi cette erreur à la compilation ?
 error: /home/salem/sat/lib/gcc/arm-none-eabi/4.5.2/../../../../arm-none-eabi/lib/libc.a(lib_a-setjmp.o): Conflicting CPU architectures 13/1

'''Solution''' : Voir Semaine 6


*'''old-ploytech-master''' : Ancien travail de James Snyder

 $ git checkout old-polytech-master
 $ scons board=STM32F4DSCY prog


https://github.com/SalemHarrache/elua/tree/polytech-master

===Semaine 6===

Il semblerait que l'erreur de la compilation vue la semaine dernière soit à l'origine du non fonctionnement d'eLua sur la carte. En effet, on va utiliser Sourcery G++ pour compilation au lieu de la summon-arm-toolchain.

====Mise en place de Sourcery G+====

 $ mkdir -p ~/stm32/CodeBench/
 $ cd ~/stm32/CodeBench/
 $ wget https://sourcery.mentor.com/sgpp/lite/arm/portal/package9742/public/arm-none-eabi/arm-2011.09-69-arm-none-eabi.bin

 $ sudo dpkg-reconfigure -plow dash
 $ #Réponse Non
 $ # Création du dossier d'installation
 $ sudo mkdir -p  /usr/local/CodeBench_1802_EABI
 $ sudo chown $USER.users  /usr/local/CodeBench_1802_EABI
 $ echo "export PATH=/usr/local/CodeBench_1802_EABI/bin:\$PATH" > ~/stm32/CodeBench/CodeBench_setup.sh

 $ /bin/sh arm-2011.03-42-arm-none-eabi.bin

Choisir :

*Minimal installation
*Install dir: /usr/local/CodeBench_1802_EABI
*Don't create links

Ensuite pour utiliser, avant de compiler il suffit d'ajouter le bin dans le PATH :
 $ source ~/stm32/CodeBench/CodeBench_setup.sh

==== Installation eLua====

 $ git clone git://github.com/SalemHarrache/elua.git
 $ git clone git://github.com/SalemHarrache/stlink.git
 $ cd stlink
 $ make
 $ cd ../elua/
 $ git checkout polytech-master
 $ cd romfs/
 $ wget https://raw.github.com/SalemHarrache/elua-examples/master/led/led.lua
 $ mv led.lua autorun.lua
 $ cd ../
 $ scons board=STM32F4DSCY prog
 $ '''# On flash maintenant la carte avec stlink'''
 $ sudo ../stlink/flash/st-flash write elua_lua_stm32f407vg.bin 0x08000000

'''Test OK !'''
PS : Parfois il est nécessaire de débrancher puis rebrancher la carte une fois le flash terminé (sans doute pour démarrer correctement la séquence de boot..)

===Semaine 7===

Nous avons mis en place une liaison série pour utiliser l’interprète avec le terminal.
<div style="text-align:center">[[File:Stm32F4-discovery-serial.jpg]]</div>

* PB6 <-> TX
* PB7 <-> RX
* GND <-> Ground
* 8 data bits, no parity, 1 stop bit, 115200 baud.

====Avec screen====

 $ screen /dev/ttyUSB0 115200 8n1

Ensuite normalement on doit appuyer sur le bouton reset de la carte pour avoir le shell lua, seulement ça marche pas pour nous, on des caractère compréhensible.
 $ �!�5-��-/�_Qe3=75��7!#��_�=#

===Semaine 8===

* Etude des fonctions Arduino pour un futur portage en lua pour elua.


* Commande d'un connecteur FTDI-based USB to TTL Serial Adapter Cable w/ Embedded Controller, 5V, Wire Ended ( http://www.futureelectronics.com/fr/technologies/interconnect/usb-to-ttl-rs232-rs422-rs485-cables/Pages/4880316-TTL-232R-5V-WE.aspx?IM=0 )

<div style="text-align:center;">[[File:TTL-232R-5V-WE-FTD-FNT-MED.jpg]]</div>

===Semaine 9===


Cette semaine le but est de comprendre toutes les subtilités de la programmation en Lua, et les principale différences par rapport aux autres langages (Python)

====Objectifs====
* Formation Lua : http://www.lua.org/docs.html
* Commencer le portage des principales fonctions Arduino en lua
* Ecrire des fichiers d'exemple d'utilisation
* Rédiger une mini docs

===Semaine 10===

====Lancement d'un programme a partir du shell Elua====

Elua propose un shell embarqué. Pour l'activer, il faut décommenter la ligne suivante dans le fichier '''elua/src/platform/stm32f4/platform_conf.h'''
<pre>
//#define BUILD_SHELL
</pre>

Puis compiler et flasher la carte avec l'image binaire générée. Maintenant on branche la carte en liaison série :
* PB6 <-> TX
* PB7 <-> RX
* GND <-> Ground
* 8 data bits, no parity, 1 stop bit, 115200 baud.

On se connecte avec screen

 '''$ screen /dev/ttyUSB0 115200 8n1
 '''eLua dev-1b3d785  Copyright (C) 2007-2011 www.eluaproject.net
 '''eLua# help
 '''Shell commands:
 ''' exit        - exit from this shell
 ''' help        - print this help
 ''' ls or dir   - lists filesystems files and sizes
 ''' cat or type - lists file contents
 ''' lua [args]  - run Lua with the given arguments
 ''' recv [path] - receive a file via XMODEM, if there is a path, save                there, otherwise run it.  cp <src> <dst> - copy source file 'src' to 'dst'
 ''' ver         - print eLua version
 '''eLua# ls

 ''' /rom
 ''' arduino_wraper.lua             1976 bytes
 ''' autorun.lua                    679 bytes

 '''  Total on /rom: 2655 bytes
 '''
 ''' eLua# lua /rom/autorun.lua
 ''' Press CTRL+Z to exit Lua
 ''' Run : Blink led

On peut également lancement l'interprète lua pour composer des programmes dynamiquement !

 '''eLua# lua
 '''Press CTRL+Z to exit Lua
 '''Lua 5.1.4  Copyright (C) 1994-2011 Lua.org, PUC-Rio
 '''> ledpin = pio.PD_12
 '''> pio.pin.setdir( pio.OUTPUT, ledpin )
 '''> pio.pin.sethigh( ledpin ) -- allume la LED
 '''>

===Semaine 11===
flash et arduino_wraper

===Semaine 12===

Nous arrivons à bout du projet. Nous avons actuellement une solution à proposer pour écrire un programme simple en lua dans l'esprit Arduino.

Voici l'exemple du blink en lua et en c (arduino)

'''Version Lua'''
<pre>
--  Blink
--  Turns on an LED on for one second, then off for one second, repeatedly.
--  This example code is in the public domain.
require("arduino_wraper")

function App:setup()
    self.ledpin = getPin("PD_13") -- Pin PD_13 has a LED connected
    pinMode(self.ledpin, OUTPUT) -- Initialize the digital pin as an output.
end

function App:loop()
    digitalWrite(self.ledpin, HIGH)    -- set the LED on
    delay(1000)                        -- wait for a second
    digitalWrite(self.ledpin, LOW)     -- set the LED off
    delay(1000)                        -- wait for a second
end

app = App:new("Blink led")
app:run()
</pre>


'''Version Arduino'''
<pre>
/*
  Blink
  Turns on an LED on for one second, then off for one second, repeatedly.

  This example code is in the public domain.
 */

void setup() {
  // initialize the digital pin as an output.
  // Pin 13 has an LED connected on most Arduino boards:
  pinMode(13, OUTPUT);
}

void loop() {
  digitalWrite(13, HIGH);   // set the LED on
  delay(1000);              // wait for a second
  digitalWrite(13, LOW);    // set the LED off
  delay(1000);              // wait for a second
}
</pre>

Il nous reste encore :
* Compléter les exemples
* Rédiger une mini docs
* faire le rapport/présentation pour la soutenance.

== Echange enseignant==
Tests réussis avec la carte STM32F4-DISCOVERY
* Test de chaîne de compilation [https://sourcery.mentor.com/sgpp/lite/arm/portal/release1802  Sourcery G++ Lite 2011.03-42 for ARM EABI]. Pour la compilation on utilise entre autres, --mcpu=cortex-m4
* Test de [https://github.com/texane/stlink | stlink] sous linux pour le chargement de programme. Tutoriel OK avec l'application blink_F4.elf (et chargement en ram). '''Test avec flash de la mémoire non-effectuée'''

